//***********
//* Poseid5 *
//***********

//Roberto Maugeri Agosto 2003
//zoom@pa.ingv.it

Versione$="Poseid5 Agosto 2003"

//Poseid5
//Implementato lo scarico incrementale senza cancellare la memoria
//A tale scopo sono state aggiunte le variabili EndHeader e StartData e un micromenu
//durante l'acquisizione.


//Poseid4
//Aggiunte le routine
//ComputeCecksum
//WarmBoot
//ColdBoot
//TurnModemOffTimer
//e midificata la routine GetStation

//Poseid3
//Aggiunta la variabile Versione e la
//corrispondente routine per conoscere la versione del firmware
//Aggiunta la routine Get station name (30)
//Aggiunte le routine per l'accensione e
//spegnimento del modem


//Poseid2
//Aggiunto il dump delle variabili in ram


//Poseid1
//ricavato da Multp13
//Cambiate le scritte da Multipar in Poseidon
//Aggiunto il doppio blink nella sezione di attesa per avvio

//Multp13
// ripulito da viola 20/9/00
// controllato da Roberto
//Aggiunto il controllo dello stato del modem anche nel ciclo di
//attesa per l'inizio dell'acquisizione (routine AttesaStart)

//Multp12
//Adesso nel test si possono usare o la conducibilita' o il ph+temperatura
//ma la misura e' pero' corretta' poiche' uno dei due e' sempre spento.
//Vengono soppressi tutti i print nel loop di acquisizione
//Eliminare tutto quanto riguarda la batteria tampone
//Ripristinato il controllo livello batteria
//Nella taratura dei sensori eliminato il ciclo di attesa. Sara'
//l'interfaccia che se ne occupera'.
//Aggiunte le routine per la stampa dell'ora attuale e di DFMAX

//Multp11
//Usare solo programmazione per i fattori batteria
//Implementati i comandi di accensione e spegnimento linee
//extern (18 e 19) e INH (20 e 21) per cui nelle routines di
//taratura questo controllo e' spento.


//Multp10
//Il fattore di moltiplicazione per la batteria viene messo su variabile BattFact!
//e su UEEPROM

//Multip9
//Modificata routine senstest, che tiene sempre acceso int 12 e inh della conduc.


//Multip8
//Implementata l'accensione e spegnimento del modem a tempo nella routine
//di acquisizione LoopAcq:
//L'orario sta su UUEEPROM ed e' modificabile da menu, routine CambiaOrario:
// e c'e' un controllo per vedere se l'orario e' umano poco prima di main
//Aggiunto lo scarico dell'orario di accensione e spegnimento, routine ScaricaOrario:
//


//Multip7
//Versione con aggiunti dei XMIT- per l'utilizzo con il modem GSM
//Eliminata la stampa di OKOFF

//Multp6
//Nel tentativo di eliminare, almeno fino a nuova versione di TFTOOLS,
//il problema sotto esposto si utilizza una nuova routine di
//attesa del tempo di campionamento. Praticamente il 68HC11 dorme
//per intervalli di 30 secondi passati i quali controlla che sia ora
//di fare misure. Aggiunte variabili Tultima e Tprossima che rappresentano
//il tempo dell'ultima misura e quello della prossima in secondi.
//Modifiche per il modem: Inibite molte stampe tramite XMIT-
//Adesso la linea Extern viene alimentata solamente per
//le misure, il test e il test batteria
//Corretto il test sulla batteria mettendo il valore apposito
//di vBattRif!
//Adesso memorizza anche la temperatura interna sul 4 e la
//tensione della batteria

//Multp5
//Modificate ancora le routine di hyb nel tentativo
//di rimanere immuni da disturbi
//Esperimenti non rusciti: Il problema sta nel fatto
//che se mentre viene eseguita l'istruzione HYB (dopo la PICINT)
//ci sono dei disturbi sulla linea d'interrupt 16 il PIC
//diventa sordo agli interrupt fino alla scadenza del
//tempo dell'HYB


//Multp4
//Derivato da Multp1
//Modificata uscita da ciclo HYB a causa del fatto che si aveva
//interruzione al lancio del programma tftools
//Nella routine dormi non si stampa nulla!

//Multp1
//Derivato da MH4g
//Modifiche varie per modello senza tastiera e LCD
//Cercare //Modifica per modello senza tastiera e LCD
//Aggiunto il canale I/O INH=17 per controllare l'alimentazione
//di alcuni sensori e non di altri Quando si misura la
//conducibilita' gli altri, e particolarmente il Ph, devono
//essere spenti.
//Modificata di conseguenza la routine di acquisizione


//Controllo versione TFBasic
IF VERS<107
	PRINT"Versione TFBasic errata ",VERS," invece di 107"
	STOP
ENDIF

//Connessioni
//Nome		TFX11	pin

//				6	LM385/2.5V
//				7	12V

//Multi0	io19	B17	Multiplexer Linea di controllo A pin11
//Multi1	io20	B16	B pin 10
//Multi2	io21	B15	C pin 9
//MultiINH	io22	B14	INH pin 6
//MultiIn	chan10	A46	Multiplexer Linea di lettura analogica pin 3 -> Pin 2 LMC6462 pin 1 ->TFX A46


//INH		io17	B19
//Extern	io23	B13	Controllo alimentazione dispositivi esterni
//ExtModem	io18	B18	Controllo alimentazione modem

//Batt		chan18	A33	Lettura tensione batteria

//Trigger	io16	B20	Trigger

//Connettere VRL (A34) e VRH(A35) rispettivamente a GND e 5V
//Mettere un condensatore di bypass (p.209)

//ROUTINES
//InitLcd	Routine inizializzazione dell'LCD
//OffLcd	Routine spegnomento software LCD
//OnLcd		Routine accensione software LCD (una volta spento con OffLcd)
//CmdLcd	Routine di comandi per l'LCD
//SetCarLcd	Routine posizionamento carattere sull'LCD
//SetCurLcd	Routine spostamento cursore sull'LCD
//CurOnLcd	Routine Cursore ON
//CurOffLcd	Routine Cursore OFF
//ClrLcd	Routine CLEAR
//ClrLcd1	Routine Clr prima riga
//ClrLcd2	Routine Clr seconda riga
//MsgMblLcd1	Routine messaggio a scorrimento Ia riga
//MsgMblLcd2	Routine messaggio a scorrimento IIa riga
//SndMsgLcd1d	Routine messaggio su primariga via DDRAM
//SndMsgLcd1	Routine messaggio su primariga via comunicazione semplice
//SndMsgLcd2d	Routine messaggio su secondariga via DRAM
//SndMsgLcd2	Routine messaggio su secondariga via comunicazione semplice
//NewChar	Definizione nuovo carattere (c)

//InfoView	Routine visualizzazione Informazioni
//CheckBat	Routine di misura della tensione della batteria
//CheckPan	Routine di misura tensione del pannello solare
//Int2Volt	Routine conversione da binario a volt range 0-5
//Int2Volt2	Conversione da intero a volt range -2.5 2.5
//Copyright	Routine di copyright
//GetTime	Copia le variabili ?() in year, month... e time
//TestPC	Esegue un test di SimVibro
//ScarErr	Scarica su RS232 gli eventuali errori memorizzati
//Errori	Routine gestione errori
//StopPrg	ferma il programma sul datalogger
//Dormi		Mette il TFX11 in modalita' basso consumo
//EraseData	Cancella tutto il datafile nella Flash
//InfoAcq	Stampa informazioni sulle acquisizioni fatte


Debug=1

//VARIABILI GLOBALI

Messaggio$=""		//Messaggio da stampare su una riga
iBatt=0			//Tensione batteria in binario
vBatt!=0		//Tensione batteria in Volt
vBattRif!=10.5		//Tensione minima della batteria
//BattFact!=2.8
BattFact! = ASFLT(VGET(14))
Intg=0			//Intero generico
volt!=0			//Tensione generica
Dati=0			//Numero dati raccolti
Interval=3600		//Intervallo di campionamento
MaxDati=15232		//Massimo numero di dati nell'array predefinito @ Pag.70
DIM Dum1(101)		//Array di dati temporanei per il calcolo delle medie
BProva=100		//Numero di elementi nei tre array precedenti
OffX=0			//Offset da calcolare per il canale X
OffY=0
OffZ=0
Spunt=0			//Copia di DFPNT
RecordBytes=100

EndHeader=0		//Ultimo byte dell'Header
StartData=0		//Primo byte di dati da scaricare

//**Variabili per la Data e Orario**
year=1999		//Anno attuale
month=1			//Mese attuale
day=1			//Giorno attuale
hour=0			//Ora attuale
minute=0		//Minuti attuali
time$="12:00"		//Ora e minuti attuali
date$="01/01/1999"	//Data attuale
seconds=0		//Secondi attuali
tics=0			//Centesimi di secondi attuali
Partenza=0		//Data di partenza
DIM TP(6)		//Data partenza programmata
Scaricato=0		//I dati sono stati scaricati (1=NON sono stati scaricati)
Tultima=?		//Tempo ultima acquisizione
Tprossima=?+100		//Tempo prossima acquisizione

//***LCD**
Messaggio$=""		//Messaggio da stampare su una riga
lMessaggio=0		//Lunghezza messaggio
LcdMsg$=""		//Messaggio di 20 caratteri max da mandare all'LCD
lLcdMsg=0		//Lunghezza messaggio
LcsCur=1		//Posizione attuale del cursore dell'LCD
DIM LcdDram (21)	//Copia della ram dati dell'LCD
LcdCmd=1		//Comando per l'LCD
Riga=1			//Riga su cui scrivere il messaggio
LcdDelay1=2		//Ritardo tra comandi LCD
Delay1=100		//Ritardo per la visualizzazione


//**Hardware**
Temp0=0			//Canale analogico Temperatura 0
Temp1=2
Temp2=4
Temp3=6
Temp4=8
Est0=1			//Canale analogico Estensimetro 0
Est1=3
Est2=5
Est3=7
Est4=9
Multi0=19
Multi1=20
Multi2=21
MultiINH=22
MultiIn=10
INH=17			//
Batt=18			//Canale analogico tensione batteria

Gae=0			//Canale di controllo

RS=5			//R/S LCD

Trigger=16		//Linea Trigger

CS=2			//Linea di controllo  MAX550
SCLK=4
DOUT=7
SN=VGET(31)  //PEEK(&HFEDD)*65536+PEEK(&HFEDE)*256+PEEK(&HFEDF)   //Numero di serie
Stopp=12		//Tasto Stopp o ALT
pStop=4096		//peso del pin
Stampa=13		//Tasto Print
pStampa=8192
Stampa=9		//Tasto Print
pStampa=512

Extern=23		//Pin strumentazione esterna
ExtModem=18	//io18	B18	Controllo alimentazione modem

pTastImp=pStop+pStampa

// Variabili eventualmente incluse nella UEEPROM
Uinterval=0	//0 Intervallo di campionamento in RATE
Uarray=1	//1 Puntatore array @
Uflash=2	//2 Puntatore Flash
Uerr=3		//3 Codice Errore
UTempoAcq=4	//4Tempo di acquisizione in secondi
UTrigLev=5	//5 Trigger



//Dati utente
Stazione$="Poseidon"	//Nome della Stazione
CanaleNome$=""
DIM CanaleNomep(19)	//Nome del Canale
DIM CanaleAttivo(19)	//Indica se il canale e' attivo o meno
CanaleUnita$=""
DIM CanaleUnitap(19)
DIM CanaleBitmin(19)
DIM CanaleBitmax(19)
DIM CanaleValmin!(19)
DIM CanaleValmax!(19)
DIM CanaleValoff!(19)
DIM CanaleADC(19)
DIM CanaleMisura!(19)
DIM CanaleVolt!(19)
DIM CanaleChan(19)
MaxCanali=17

FOR i = 0 TO 18
	CanaleNomep(i)=0
	CanaleAttivo(i)=0
	CanaleUnitap(i)=0
	CanaleBitmin(i)=0
	CanaleBitmax(i)=65535
	CanaleValmin!(i)=0
	CanaleValmax!(i)=5
	CanaleValoff!(i)=0
	CanaleADC(i)=0
	CanaleMisura!(i)=0
	CanaleVolt!(i)=0
NEXT i


FOR i = 0 TO 9
	CanaleChan(i)=i
NEXT i

//Selezione corrispondenza tra canali in vb
//e canali multiplexer
FOR i = 10 TO MaxCanali
	CanaleChan(i)=i-10
NEXT i

//Inversione
FOR i = 10 TO MaxCanali
	CanaleChan(i)=7-CanaleChan(i)
NEXT i


//CanaleAttivo(0)=1
//CanaleAttivo(2)=1
//CanaleAttivo(13)=1


//CanaleChan(0)=0
//CanaleChan(1)=1
//CanaleChan(2)=2
//CanaleChan(3)=3
//CanaleChan(4)=4
//CanaleChan(5)=5
//CanaleChan(6)=6
//CanaleChan(7)=7
//CanaleChan(8)=8
//CanaleChan(9)=9

DIM iTemp(5)		//Ultime temperature valore ADC
DIM vTemp!(5)		//Ultime temperature in volt
DIM cTemp!(5)		//Ultime temperature in C
DIM iEst(5)		//Idem per gli estensimetri
DIM vEst!(5)
DIM cEst!(5)
DIM iClin(5)		//Idem per i clinometri
DIM vClin!(5)
DIM cClin!(5)



PCLR MultiINH			//Attivazione CD4051

CBREAK Com		//attivazione della routine CTRL+C in caso di segnale da RS232

GOSUB GetTime		//Aggiornamento data


//Lettura variabili da UEEPROM
//Interval=VGET(Uinterval)


aOra=VGET(10)		//Prende l'orario di accensione e spegnimento dall'UUEEPROM
aMinuti=VGET(11)
sOra=VGET(12)
sMinuti=VGET(13)

IF aOra<0 | aOra >23		//Controlla che sia corretto
	aOra=20
	VSTORE 10,aOra
ENDIF
IF sOra<0 | sOra >23
	sOra=21
	VSTORE 12, sOra
ENDIF

IF aMinuti<0 | aMinuti>59
	aMinuti=0
	VSTORE 11,aMinuti
ENDIF
IF sMinuti<0 | sMinuti>59
	sMinuti=0
	VSTORE 13, sMinuti
ENDIF



XMIT+

ModemOn=1
PSET ExtModem


Errore=0
ErrCode=0



//Azzera il byte di oversleep (vedi manuale pag. 120)
POKE &H9E,0

//Intervallo per l'istruzione sleep 10.0 mS
//RATE 1

//**********   MAIN   ****************************************************

XMIT-


Errore=0
ErrCode=0




				//**Controllo tensione batteria ed eventuale allarme**
PSET Extern			//Accensione dispositivi esterni

PCLR Gae

GOSUB CheckBat			//Misura tensione batteria
IF vBatt!<vBattRif!
	PCLR ExtModem
	GOTO Dormi
ENDIF
PCLR Extern



//***************************** Attesa comandi da porta seriale ***********
Com:
XMIT+
CBREAK Comandi


Comandi:	//Da qui a GOTO Comandi c'e' la routine di attesa comandi
XMIT+
tCom=?		//Memorizzazione tempo inizio routine comandi
XMIT+
PCLR Extern
PCLR INH
PRINT"Poseidon"


Comandi2:

//PRINT"1  Acquisizione"
//PRINT"2  ScaricoDati"
//PRINT"3  Dormi"
//PRINT"4  Ultimi dati"
//PRINT"5  WarmStart"
//PRINT"6  Torna al controllo da tastiera"
//PRINT"7  EraseData"
//PRINT"8  InfoAcq"
//PRINT"10 Test sensori"
//PRINT"11 Scarica programmazione"
//PRINT"12 Tara Ph"
//PRINT"13 Tara Temperatura"
//PRINT"14 Tara conducibilita'"
//PRINT"15 Tara Temperatura interna"
//PRINT"16 Cambia orario accensione Modem"
//PRINT"17 Scarica orario accensione modem"
//PRINT"18 Accensione Extern"
//PRINT"19 Spegnimento Extern"
//PRINT"20 Accensione INH"
//PRINT"21 Spegnimento INH"
//PRINT"22 lbattfact"
//PRINT"23 rbattfact"
//PRINT"24 Scarica orario Centralina"
//PRINT"25 Scarica quantita' di memoria"
//PRINT"26 Accendi il modem"
//PRINT"27 Spegni il modem"
//PRINT"28 Spegne il modem per 5 secondi"
//PRINT"30 Get Station name"
//PRINT"49 Dump memoria"
//PRINT"50 Stampa Versione"
//PRINT"89 ComputeCecksum"
//PRINT"90 DFPNT"
//PRINT"91 WarmBoot"
//PRINT"92 ColdBoot"
//PRINT"93 Test LCD"
//PRINT"94 TestPC"
//PRINT"95 XMIT+"
//PRINT"96 Copyright"
//PRINT"97 ScarErr"
//PRINT"98 Scarico Emergenza"
//PRINT"99 Stop"
//PRINT
//PRINT"Comando"
XMIT-
INPUT "" Comando // ,1*100
XMIT+




//Qui si mette l'esecuzione dei vari comandi
IF Comando=1
	XMIT-
	GOTO Acquisizione		// Fa partire l'acquisizione
	tCom=?
ENDIF
IF Comando=2
	XMIT+
	GOSUB ScaricoDati		// Scarica i dati
	tCom=?
ENDIF
IF Comando=3
	XMIT-
	GOSUB Dormi			// Lo manda in low power mode
	tCom=?
ENDIF
IF Comando=4
	GOSUB Conversioni
	//GOSUB InfoView			//Controllo su LCD
	tCom=?
ENDIF
IF Comando=5
	GOSUB WarmStart			//Partenza con dati preprogrammati
	tCom=?
ENDIF
IF Comando=6
	CBREAK Com			//Torna alla normale gestione di CTRL+C
	//GOSUB PolTast			//Polling Tastiera
	tCom=?
ENDIF
IF Comando=7
	GOSUB EraseData			//Va alla cancellazione della Flash
	tCom=?
ENDIF
IF Comando=8
	GOSUB InfoAcq			//Stampa informazioni sulle acquisizioni fatte
	tCom=?
ENDIF
IF Comando=10
	GOSUB SensTest			//prende la copia di dfnpt (Spunt)
	tCom=?
ENDIF
IF Comando=11
	GOSUB ScaricoProgrammazione	//Scarica la programmazione eventualmente presente in memoria
ENDIF
IF Comando=12
	GOSUB TaraPh			//Prende una misura di Ph per la taratura
ENDIF
IF Comando=13
	GOSUB TaraTemp			//Prende una misura di temperatura per la taratura
ENDIF
IF Comando=14
	GOSUB TaraCond			//Prende una misura di conducibilita' per la taratura
ENDIF
IF Comando=15
	GOSUB TaraTempInt		//Prende una misura di temperatura interna per la taratura
ENDIF
IF Comando=16
	GOSUB CambiaOrario		//Cambia l'intervallo di accensione del modem
ENDIF
IF Comando=17
	GOSUB ScaricaOrario		//Scarica orario accensione modem
ENDIF
IF Comando=18
	GOSUB ExternOn			//Accensione linea Extern
ENDIF
IF Comando=19
	GOSUB ExternOff			//Spegnimento linea Extern
ENDIF
IF Comando=20
	GOSUB INHOn			//Spegnimento linea INH
ENDIF
IF Comando=21
	GOSUB INHOff			//Spegnimento linea INH
ENDIF
IF Comando=22
	GOSUB lBattFact			//Stampa il fattore batteria
ENDIF
IF Comando=23
	GOSUB rBattFact			//Memorizza il fattore batteria
ENDIF
IF Comando=24
	GOSUB rOrario			//Stampa l'orario centralina
ENDIF
IF Comando=25
	GOSUB rDFMAX			//Stampa la quantita' di memoria
ENDIF					//totale per i dati nella flash

IF Comando=26
	GOSUB TurnModemOn		//Accende il modem
ENDIF
IF Comando=27
	GOSUB TurnModemOff		//Spegne il modem
ENDIF
IF Comando=28
	GOSUB TurnModemOffTimer		//Spegne il modem per 5 secondi
ENDIF

IF Comando=30
	GOSUB GetStation			//Prende il nome stazione
ENDIF

IF Comando=49
	GOSUB DumpRam			//Dump Variabili in ram
ENDIF

IF Comando=50
	GOSUB PrintVersion		//Stampa la versione del firmware
ENDIF

IF Comando=89
	GOSUB ComputeCecksum
	//tCom=?
ENDIF
IF Comando=90
	GOSUB GetDfpnt			//prende la copia di dfnpt (Spunt)
	tCom=?
ENDIF
IF Comando=91
	GOSUB WarmBoot
	//tCom=?
ENDIF
IF Comando=92
	GOSUB ColdBoot
	//tCom=?
ENDIF
IF Comando=93
	//GOSUB TestLCD			//Controlli vari mandati al PC
	tCom=?
ENDIF
IF Comando=94
	GOSUB TestPC			//Controlli vari mandati al PC
	tCom=?
ENDIF
IF Comando=95
	Xmit+				//Xmit+
	GOTO Comandi
	tCom=?
ENDIF
IF Comando=96
	//GOSUB Copyright
	tCom=?
ENDIF
IF Comando=97
	//GOSUB ScarErr			// Scarico errori
	tCom=?
ENDIF
IF Comando=98
	GOSUB Scarico_emergenza	// Scarico di tutto l'array @ in mancanza di puntatore
	tCom=?
ENDIF
IF Comando=99
	GOTO StopPrg		// Ferma il programma
ENDIF

Comando=0

GOTO Comandi2

//**************************** Programmazione acquisizione ***************
Acquisizione:
//Qui si fa partire l'acquisizione




//Acquisizione nome stazione

XMIT-
INPUT "" Stazione$;
XMIT+
IF LEN(Stazione$)>32
	Stazione$=MID(Stazione$,1,32)
ENDIF


//Input data e ora dal PC
Dummy=0
XMIT-
INPUT "" Dummy;
XMIT+
IF Dummy <> 1
	GOTO Noora
ENDIF

XMIT-
INPUT "" ?(5);	//Anno
INPUT "" ?(4);	//Mese
INPUT "" ?(3);	//Giorno
INPUT "" ?(2);	//Ora
INPUT "" ?(1);	//Minuti
INPUT "" ?(0);	//Secondi
XMIT+


STIME		//La scarica in ?
SETRTC		//Scarica ? sull'orologio del PIC
Noora:
READRTC
RTIME


XMIT-
INPUT "" Dummy;
XMIT+
IF Dummy=1
	XMIT-
	INPUT "" TP(5); // Anno
	INPUT "" TP(4); // Mese
	INPUT "" TP(3); // Giorno
	INPUT "" TP(2); // Ora
	INPUT "" TP(1); // Minuti
	INPUT "" TP(0); // Secondi
	XMIT+
	QuandoPar=0
ELSE

	FOR i = 0 TO 5				// Copia la data attuale
		TP(i)=?(i)
	NEXT i
	QuandoPar=1
ENDIF

FOR i = 0 TO 5			//Trasforma la data di partenza in numero
	?(i)=TP(i)
NEXT i
STIME Partenza		// Partenza e' un numero che contiene la data di partenza



XMIT-
INPUT "" Interval
XMIT+

//		  1	    2	      3		4
/////////12345678901234567890123456789012345678901234567890123456
MsgLcd$="Mlt SIMA S.r.l. Roberto Maugeri (c)1999"
//Pare che ci siano problemi sul primo blocco di 32 bytes della memoria
//Flash per cui ci metto una frase di copyright!
//ATTENZIONE!!!! non cambiare la lunghezza della stringa
//in MsgLcd!!

STORE MsgLcd$

FOR i = 0 TO MaxCanali
	XMIT-
	INPUT "" CanaleNome$
	CanaleNomep(i)=DFPNT
	IF CanaleNome$="" CanaleNome$=" "
	STORE CanaleNome$
	INPUT "" CanaleAttivo(i)
	STORE #1, CanaleAttivo(i)
	INPUT "" CanaleUnita$
	CanaleUnitap(i)=DFPNT
	IF CanaleUnita$="" CanaleUnita$=" "
	STORE CanaleUnita$
	INPUT "" CanaleBitmin(i)
	STORE #4, CanaleBitmin(i)
	INPUT "" CanaleBitmax(i)
	STORE #4, CanaleBitmax(i)
	INPUT "" CanaleValmin!(i)
	STORE #4, CanaleValmin!(i)
	INPUT "" CanaleValmax!(i)
	STORE #4, CanaleValmax!(i)
	INPUT "" CanaleValoff!(i)
	STORE #4, CanaleValoff!(i)
	XMIT+
	CanaleADC(i)=0
	CanaleMisura(i)=0
	CanaleVolt(i)=0
	Spunt=DFPNT
NEXT i

EndHeader=DFPNT-1
StartData=DFPNT

XMIT+
PRINT "PARTITO!"			//Partiamo!
XMIT-	//Disabilita ogni output sulla RS232
CBREAK Com
SLEEP 0
SLEEP Delay1
PCLR Extern
PCLR INH

Scaricato=1
Dati=1
error=0
SLEEP 0
HYB 0

//Azzera il byte di oversleep (vedi manuale pag. 120)
POKE &H9E,0


RTIME
STIME Dummy
IF QuandoPar=1
	GOTO IniAcq
ENDIF


AStart=0			//Controllo che si sia raggiunta la data di partenza
AttesaStart:
REPEAT
	RTIME
        STIME Dummy
	IF Dummy>=Partenza
		AStart=1
	ENDIF

	RTIME
	//Siccome il confronto risulta complesso considerando ora e minuti separatamente
	//trasformo l'ora e minuti in ora decimale.
	Now!=?(2)+FLOAT(?(1))/60
	aOrad!=aOra+FLOAT(aMinuti)/60
	sOrad!=sOra+FLOAT(sMinuti)/60

	IF Now!>=aOrad! & Now! < sOrad
		IF ModemOn=0
			PSET ExtModem
			ModemOn=1
		ENDIF
	ELSE
	// controlla che non sia ora di spegnere

		IF ModemOn=1
			PCLR ExtModem
			ModemOn=0
		ENDIF
	ENDIF

	PSET Extern
	SLEEP 10
	PCLR Extern
	SLEEP 10
	PSET Extern
	SLEEP 10
	PCLR Extern


	PICINT 1,0
	HYB 0
	HYB 5
	IF INTSTATE=0
		Dummy=1
		SLEEP 0
		SLEEP 50
		GOTO AttesaStart
	ENDIF

        // controlla ogni 10 secondi che non sia l'ora di partire. Nell'attesa dorme
UNTIL AStart=1

IniAcq:

SLEEP 0
GOTO LoopAcq



//*****************  WarmStart partenza con dati preprogrammati  *********
WarmStart:
PRINT "WarmStart"

TP(5) =?(5)
TP(4) =?(4)
TP(3) =?(3)
TP(2) =?(2)
TP(1) =?(1)
TP(0) =?(0)


Interval=60			//CANCELLA
PRINT"Interval ",Interval

IF Stazione$=""
	Stazione$="Vuoto"
ENDIF

GOTO LoopAcq				//salta al loop di acquisizione



//*************************** Loop di acquisizione  **********************
LoopAcq:
XMIT-
PSET Extern		//Accensione apparecchiature esterne
FOR i=0 TO 4
	iTemp(i)=0		//Ultime temperature valore ADC
	vTemp!(i)=0		//Ultime temperature in volt
	cTemp!(i)=0		//Ultime temperature in C
	iEst(i)=0		//Idem per gli estensimetri
	vEst!(i)=0
	cEst!(i)=0
	iClin(i)=0		//Idem per i clinometri
	vClin!(i)=0
	cClin!(i)=0
NEXT i

iBatt=0			//Tensione batteria in binario
vBatt!=0		//Tensione batteria in Volt
Intg=0			//Intero generico
volt!=0			//Tensione generica
EPartenza=0		//Data effettiva di partenza
Scaricato=1
Dati=0
Intg=0			//Intero generico
volt!=0			//Tensione generica
SLEEP 0
HYB 0

//Azzera il byte di oversleep (vedi manuale pag. 120)
POKE &H9E,0

//Registrazione su flash dei dati iniziali

IF MID(Stazione$,LEN(Stazione$),1) < " "    //<32
	Stazione$=MID(Stazione$,1,LEN(Stazione$)-1)
ENDIF
IF LEN(Stazione$)<32
	Stazione$=Stazione$+"                                   "
	Stazione$=MID(Stazione$,1,32)
ENDIF

STORE Stazione$		//Memorizza Stazione$ nella Flash

pSN=DFPNT

STORE #4,SN		//Numero di serie nella Flash

pTP=DFPNT
		//Data partenza nella Flash
STORE #4, TP(5) // Anno
STORE #4, TP(4) // Mese
STORE #4, TP(3) // Giorno
STORE #4, TP(2) // Ora
STORE #4, TP(1) // Minuti
STORE #4, TP(0) // Secondi

pInterval=DFPNT
STORE #4, Interval	//Intervallo di acquisizione in secondi nella Flash

Spunt=DFPNT

//Azzera il byte di oversleep (vedi manuale pag. 120)

POKE &H9E,0
FOR i = 0 TO MaxCanali
	IF CanaleAttivo(i)<>0
		//PRINT i,", ";
	ENDIF
NEXT i

Tultima=?		//Tempo ultima acquisizione aggiornato
			//alla prima volta
Tprossima=Tultima	//Serve solo la prima volta


Loop:		//Loop di acquisizione


Parti:
EventTime = ?		// start time in seconds
Tultima=Tprossima	//

// Accende Le apparecchiature esterne
PSET Extern
PSET INH
//Piccola pausa
//oppure sleep o HYB
SLEEP 0
SLEEP 2000



//Acquisizione canale 0 Temperatura

Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(CanaleChan(0))
NEXT j
CanaleADC(0)=INT(FLOAT(Somma/BProva)+0.5)/16


//Acquisizione rimanenti canali 2 e 3 Livello e Ph
FOR i = 2 TO 3
	Somma=0
	FOR j = 1 TO BProva
		Somma=Somma+CHAN(CanaleChan(i))
	NEXT j
	CanaleADC(i)=INT(FLOAT(Somma/BProva)+0.5)/16
NEXT i


PCLR INH

SLEEP 0
SLEEP 2000

//Acquisizione Canale 1 Conducibilita'
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(1)
NEXT j
CanaleADC(1)=INT(FLOAT(Somma/BProva)+0.5)/16

GOSUB CheckBat		//Misura tensione batteria

//Acquisizione canale 4 Temperatura interna
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(CanaleChan(4))
NEXT j
CanaleADC(4)=INT(FLOAT(Somma/BProva)+0.5)/16


PSET Gae

POKE &H9C,0			//Disabilita il CTRL+C

STORE #2,CanaleADC(0)
STORE #2,CanaleADC(1)
STORE #2,CanaleADC(2)
STORE #2,CanaleADC(3)
STORE #2,CanaleADC(4)
STORE #2,iBatt/16		//Memorizza la tensione della batteria
POKE &H9C,1			//Riabilita il CTRL+C

PCLR Gae

Spunt=DFPNT


GOSUB CheckBat			//Controlliamo la batteria principale
IF vBatt!<vBattRif!
	PCLR Extern
	PCLR INH
	PCLR ExtModem
	GOTO Dormi
ENDIF

//Fine acquisizione

PCLR Extern
PCLR 0,1,2,3,4,5,6,7,17,19,20,21,22,23	//Spegne tutto TRANNE L'INTERRUPT e il modem (18)

Time2=?


Dati=Dati+1
MemoriaRimasta=DFMAX-DFPNT
IF MemoriaRimasta<RecordBytes
	GOTO Dormi
ENDIF



//Attesa per la prossima misura
//Toglie un secondo che e' circa il tempo impiegato per la misura
tempo=Interval

Tprossima=Tultima+Interval	//Calcolo tempo prossima acquisizione

loop2:
tempo=30	//Impostazione tempo per HYB
t0=?

loop1:

IF tempo<0 tempo=0

PCLR Extern
PCLR 0,1,2,3,4,5,6,7,17,19,20,21,22,23	//Spegne tutto


CBREAK Com
PICINT 1  //,1
HYB tempo


IF INTSTATE=0

	IF ? >= Tprossima
		GOTO Loop
	ENDIF
	Dummy=1
	IF Dummy<>0
		SLEEP 0			//Attesa 0.75 secondi
		SLEEP 75		//Il tasto e' ancora premuto?
			t2=?
			tempo=30-(t2-t0)
			HYB 0
			GOTO loop1
	ENDIF
	t2=?
	tempo=Interval-(t2-t0)
	HYB 0
	//PRINT "INTSTATE"
	GOTO loop2
ENDIF

//Controllo che non sia ora di accendere il modem
// ?(2);	//Ora
// ?(1);	//Minuti


RTIME
//Siccome il confronto risulta complesso considerando ora e minuti separatamente
//trasformo l'ora e minuti in ora decimale.
Now!=?(2)+FLOAT(?(1))/60
aOrad!=aOra+FLOAT(aMinuti)/60
sOrad!=sOra+FLOAT(sMinuti)/60

IF Now!>=aOrad! & Now! < sOrad
	IF ModemOn=0
		PSET ExtModem
		ModemOn=1
	ENDIF
ELSE
// controlla che non sia ora di spegnere

	IF ModemOn=1
		PCLR ExtModem
		ModemOn=0
	ENDIF
ENDIF





//Controllo che non si sia raggiunto il tempo per la prossima misura

IF ?>= Tprossima
	GOTO Loop
ELSE
	PSET Extern
	GOTO loop2
ENDIF

//Fine Loop acquisizione


//---------------------------------------------------------------------------------------------
StopAcq:

//Salva il puntatore su UEEPROM posizione 5
PRINT "Ok"
GOTO Comandi

//---------------------------------------------------------------------------------------------
ScaricoDati:
RTIME


//Scrive 40 zeri di sicurezza sulla flash
//per effettuare il flush del buffer di scrittura
XMIT+
Index=0
FOR i=0 TO DFPNT-1
	dummy=GET(Index,#1)
	PRINT \dummy;	//CHR$(dummy);
NEXT i
XMIT-
Scaricato=0
RETURN


//----------------------------------------------------------------------------
StopPrg:
//Qui viene fermato il programma sul datalogger
XMIT+
//PRINT "Programma su Datalogger fermato"
//PRINT "Per ripartire CTRL+R (ASCII 18)"
STOP


//----------------------------------------------------------------------------
Dormi:

XMIT-

Dormi2:
XMIT-
PICINT 1,1
PCLR 0,1,2,3,4,5,6,7,17,19,20,21,22,23
PCLR Extern
PCLR INH
HYB 60
IF INTSTATE=0
		Dummy=1
	IF Dummy<>0
		SLEEP 0			//Attesa .5 secondi
		SLEEP 50		//Il tasto e' ancora premuto?
		Dummy=0
		IF Dummy<>0
			GOTO Comandi		//Si vai a controllo tastiera
		ELSE
			GOTO Dormi2
		ENDIF
	ENDIF

ENDIF
GOTO Dormi2
RETURN


//----------------------------------------------------------------------------
Scarico_emergenza:

RTIME

XMIT-
INPUT "" Dati
XMIT+
Index=0
FOR i=0 TO Dati
	dummy=GET(Index,#1)
	PRINT \dummy;	//CHR$(dummy);
NEXT i

RETURN



//-------------------------------------------------------
//Sub Int2Volt		Conversione da intero a volt range 0-5
Int2Volt:
//Il dato da convertire e' in Intg e quello convertito in volt!
volt!=5.0/65535.0*FLOAT(Intg)
RETURN

//-------------------------------------------------------
//Sub Int2Volt2		Conversione da intero a volt range -2.5 2.5
Int2Volt2:
//Il dato da convertire e' in Intg e quello convertito in volt!
volt!=5.0/65535.0*FLOAT(Intg)
volt!=volt!-2.5
RETURN


//-------------------------------------------------------
//Sub CheckBat  		Controllo tensione batteria
CheckBat:
iBatt=CHAN(Batt)
vBatt!=5.0/65535.0*FLOAT(iBatt)
//Conversione per effettiva tensione
vBatt!=vBatt!*BattFact!		//*****************************modificare!
RETURN


//-------------------------------------------------------
//SubGetTime	Copia le variabili ?() in year, month..., time$ e date$
//In time$ il formato e' sempre a 2 cifre.
GetTime:
READRTC
RTIME
year=?(5)		//Anno attuale
month=?(4)		//Mese attuale
day=?(3)		//Giorno attuale
hour=?(2)		//Ora attuale
minute=?(1)		//Minuti attuali
seconds=?(0)		//Secondi attuali
tics=?(6)		//Centesimi di secondi attuali
time$=STR(hour,":",minute,":",seconds)	//Ora, minuti e secondi attuali
//Conversione data da possibile h:m:s in hh:mm:ss
//padding con zero iniziale se la cifra e' singola
//Queste istruzioni sono necessarie in quanto se
//i minuti sono meno di dieci viene restituita una sola cifra
//e l'ora appare tipo 23:2:45
IF hour<10
	time$=STR("0",time$)
ENDIF
IF minute<10
	time$=STR(MID(time$,1,3),"0",MID(time$,4,10))
ENDIF
IF seconds<10
	time$=STR(MID(time$,1,6),"0",seconds)
ENDIF
date$=STR(day,"/",month,"/",year,"   ")
//Adattamento data con padding di zeri se necessari
IF day<10
	date$=STR("0",date$)
ENDIF
IF month<10
	date$=STR(MID(date$,1,3),"0",MID(date$,4,15))
ENDIF
RETURN

//-------------------------------------------------------

InfoAcq:		//Stampa informazioni sulle acquisizioni fatte
PRINT DFPNT
PSET Extern
GOSUB CheckBat			//Misura tensione batteria
PCLR Extern
PRINT #2.2F,vBatt!
PRINT SN
RETURN


//-------------------------------------------------------
//Sub Test
Test:
READRTC
RTIME
PRINT
PRINT
PRINT"Poseidon"
PRINT
PRINT"Program by Roberto Maugeri 1999"
RTIME
PRINT "Ora datalogger ",?(2),":",?(1),":",?(0);
PRINT " del ",?(3),"/",?(4),"/",?(5)
PRINT
PRINT
PRINT "Canale 0 X----------->",CHAN(0)
PRINT "Canale 1 Y----------->",CHAN(1)
PRINT "Canale 2 Z----------->",CHAN(2)
PRINT "Canale 3 Batteria---->",CHAN(3)
PRINT "Canale 4 Pannello---->",CHAN(4)
PRINT "Trigger-------------->",PIN(Trigger)
PRINT "Stop----------------->",PIN(Stopp)
PRINT
PRINT
RETURN



//----------------------------------------------------------------------------------------
TestPC:		//Esegue un test di Poseidon con uscita su RS232
PRINT""
PRINT"Poseidon"
PRINT
PRINT"Program by Roberto Maugeri Dicembre 1999"
PRINT"zoom7@freemail.it"
RTIME
PRINT "Ora datalogger ",?(2),":",?(1),":",?(0);
PRINT " del ",?(3),"/",?(4),"/",?(5)
PRINT "TFX Modello ", MODEL/100
PRINT "Numero di serie -->", SN
PRINT "TFBASIC versione -->", #1.2F,FLOAT(VERS/100)
PRINT "Baud rate corrente ",BAUDGET
PRINT "Errori matematici =",FPERR
IF BBPWR = 0
	PRINT "Alimentazione esterna"
ELSE
	PRINT "Alimentazione batteria di backup"
ENDIF

PRINT "Baudrate in ram ", PEEK(43)
PRINT "MC68HC11 Options ",#08B,PEEK(57)
PRINT "Oversleep ",#08B,PEEK(158)
PRINT "Errori partenza programma ",#08B,PEEK(160)

PRINT "Nella serial Flash ci sono ",DFMAX," bytes"
PRINT "Prossima locazione disponibile ",DFPNT
PRINT
PRINT
PRINT
INPUT "Un tasto per continuare 3 per andare alla calibrazione sensori" dummy
IF dummy = 3
	GOTO CalSens
ENDIF
PRINT
PRINT
PRINT "Configurazione porte"
PRINT
PRINT "Configurazione PIN 0-7 (Port C) ",#08B,PEEK(7)
PRINT "Configurazione Port A ",#08B,PEEK(1)
PRINT "Configurazione Port D ",#08B,PEEK(9)
PRINT "Configurazione Port G ",#08B,PEEK(3)
PRINT "Stato delle porte"
PRINT "Porta A ",#08B,PEEK(0)
PRINT "Porta B ",#08B,PEEK(4)
PRINT "Porta C ",#08B,PEEK(6)," Pin 0-7"
PRINT "Porta D ",#08B,PEEK(8)
PRINT "Porta E ",#08B,PEEK(10)," Pin 8-15 AD11-18"
PRINT "Porta F ",#08B,PEEK(5)
PRINT "Porta G ",#08B,PEEK(2)
PRINT
PRINT
PRINT
PRINT
PRINT
INPUT "Un tasto per continuare" dummy
PRINT
PRINT
PRINT
PRINT
PRINT
PRINT "Letture attuali canali analogici a 12 bit"
PRINT
PRINT"Chan0  Chan1  Chan2  Chan3  Chan4  Chan5  Chan6  Chan7  Chan8  Chan9  Chan10"
PRINT #06D,Chan(0)," ",Chan(1)," ",Chan(2)," ",Chan(3)," ";
PRINT #06D,Chan(4)," ",Chan(5)," ",Chan(6)," ",Chan(7)," ";
PRINT #06D,Chan(8)," ",Chan(9)," ",Chan(10)
PRINT
PRINT
PRINT "Letture attuali canali analogici a 8 bit"
PRINT
PRINT"Chan11 Chan12 Chan13 Chan14 Chan15 Chan16 Chan17 Chan18"
PRINT #06D,Chan(11)," ",Chan(12)," ",Chan(13)," ",Chan(14)," ";
PRINT #06D,Chan(15)," ",Chan(16)," ",Chan(17)," ",Chan(18)
PRINT
PRINT
PRINT
PRINT
PRINT
INPUT "Un tasto per continuare" dummy
PRINT
PRINT
PRINT
PRINT
PRINT "Letture sulle porte d'ingresso"
FOR i = 0 to 13
	PRINT "Pin ",i," ",pin(i)
NEXT i
PRINT "Pin 16 ",pin(16)
PRINT
PRINT
PRINT
PRINT
INPUT "Un tasto per continuare" dummy
PRINT
PRINT
PRINT
PRINT "Valori registrati in UEPROM"
FOR i=0 to 15
	Eprom=VGET(i)
	PRINT "UEEPROM n.",i," ",Eprom
NEXT i
PRINT
PRINT
INPUT "Un tasto per continuare" dummy
PRINT
PRINT
FOR i=15 to 31
	Eprom=VGET(i)
	PRINT "UEEPROM n.",i," ",Eprom
NEXT i
PRINT
PRINT
INPUT "Un tasto per continuare" dummy
PRINT
PRINT
CalSens:
PRINT "Calibrazione sensore temperatura"
PSET Extern
PRINT
PRINT
cTempAtt:
iTempAtt=CHAN(Temp1)
vTempAtt!=5.0/65535.0*iTempAtt
TempAtt!=(vTempAtt!-2.50)*100
PRINT "Temperatura ",iTempAtt," ",#3.4F,vTempAtt!," ",TempAtt!," ";
INPUT "3 per continuare"  dummy,#1
IF dummy=3
	GOTO cTempAtt
ENDIF

PRINT
PRINT
PRINT
PRINT
PRINT "Calibrazione tensione batteria"
PRINT
PRINT
cBatt:
iBatt=CHAN(Batt)
vBatt!=5.0/65535.0*FLOAT(iBatt)
vBatt!=vBatt!*2.706
PRINT "Batteria ",iBatt," ",#2.4F,vBatt!," ";
INPUT "3 per continuare" dummy, #1
IF dummy=3
	GOTO cBatt
ENDIF

PRINT
PRINT
PRINT
PRINT
PRINT "Controllo pulsantiera"
PRINT
PRINT
cpuls:
PRINT PIN(Stopp)," ",PIN(Stampa)," ",PIN(9)," ",PIN(Trigger)
INPUT "3 per continuare" dummy, #1
IF dummy=3
	GOTO cpuls
ENDIF



PCLR Extern

RETURN


//-------------------------------------------------------
WaitStart:
//Aspetta la pressione del tasto Start
IF PIN(Stampa)<>0
	GOTO WaitStart
ENDIF
RETURN


//----------------------------------------------------------------------------------------
//-------------------------------------------------------
EraseData:
//Cancella tutto il datafile nella Flash

//Modifica per modello senza tastiera e LCD

TFErr = 0               // used to signal error (non-zero if error)

asm $
SelEE   equ     H'FD8B  ; function to select flash EEPROM
SelNone equ     H'FD8E  ; function to unselect flash EEPROM
EEErase equ     H'FD85  ; function to erase a block of flash EEPROM
EEWEnab equ     H'CAF1  ; function to write enable flash EEPROM
EEWDis  equ     H'CAFD  ; function to write disable flash EEPROM
DFBlks  equ     H'13B   ; address of list of datafile blocks

        jsr     SelEE   ; select flash on SPI bus
        jsr     EEWEnab ; write enable flash (needed for erasing, too)
        ldx     #DFBlks ; X register holds address of datafile blocks
_EEClr  ldab    0,x     ; load next datafile block # in B register
        cmpb    #H'FF   ; check if this is end of list
        beq     _xeec   ; branch to _xeec if this is end of list
        jsr     EEErase ; erase the flash block whose # is in B reg
        bvs     _eecerr ; branch if time-out error on erase
        bcs     _eecerr ; branch if block did not erase
        inx             ; point to next position in datafile block list
        bra     _EEClr  ; loop back to do this block
_xeec   jsr     EEWDis  ; write disable flash EEPROM
        jsr     SelNone ; deselect flash EEPROM on SPI bus
        rts
_eecerr inc     TFErr+3 ; here if error, make value non-zero
        bra     _xeec   ; finish up as normal
        end

IF TFErr = 0
        		//OK
        POKE &hB0,0     // clear the datafile pointer
        POKE &hB1,0
        POKE &hB2,0
        POKE &hB3,0
	STOP
ELSE

	SLEEP 0
	SLEEP 200
	RETURN
ENDIF
STOP


//-------------------------------------------------------
Conversioni:			//Converte i valori misurati nelle grandezze effettive
FOR i=0 TO MaxCanali
CanaleMisura!(i)=FLOAT((CanaleADC(i)-CanaleBitmin(i)))/FLOAT((CanaleBitmax(i)-CanaleBitmin(i)))*(CanaleValmax(i)-CanaleValmin(i))+CanaleValmin(i)+CanaleValoff(i)
NEXT i

RETURN


//------------------------------------------------------
GETS2:
//Prende una stringa puntata da Intg
//Visto che GETS non funziona
GETS2s$=""
Intg2=GET(Intg,#1)
FOR Gets2i=Intg TO Intg+Intg2-1
	Gets2i2=Gets2i
	Gets21=0
	Gets21=GET(Gets2i2,#1)
	GETS2s$=GETS2s$+STR(\Gets21)
NEXT Gets2i
GETS2s$=MID(GETS2s$,1,LEN(GET2s$)-2)
RETURN
//------------------------------------------------------
GetDfpnt:
PRINT Spunt
RETURN


//--------------------------------------------------------------------------
SensTest:
//Test dei sensori in continuo

//PRINT "Test dei sensori"

GOTO Stest

XMIT-
//INPUT "" ?(5);	//Anno
//INPUT "" ?(4);	//Mese
//INPUT "" ?(3);	//Giorno
//INPUT "" ?(2);	//Ora
//INPUT "" ?(1);	//Minuti
//INPUT "" ?(0);	//Secondi
XMIT+
//?(5)=1999
//?(4)=12
//INPUT "Giorno " ?(3);	//Giorno
//INPUT "Ora " ?(2);	//Ora
//INPUT "Minuti " ?(1);	//Minuti
//?(0)=0		//Secondi

STIME		//La scarica in ?
SETRTC		//Scarica ? sull'orologio del PIC
READRTC
RTIME


Stest:

FOR i = 0 TO MaxCanali
	XMIT-
	INPUT "" CanaleAttivo(i)
	XMIT+
	CanaleADC(i)=0
	CanaleMisura(i)=0
	CanaleVolt(i)=0
NEXT i

//Controlla se Conducibilita' viene misurata.
//Se si spegne INH
PSET Extern
IF CanaleAttivo(1)<>0
	PCLR INH
ELSE
	PSET INH
ENDIF


XMIT+
PRINT "OK!"			//Partiamo!
CBREAK Com
error=0


//Azzera il byte di oversleep (vedi manuale pag. 120)
POKE &H9E,0


iBatt=0			//Tensione batteria in binario
vBatt!=0		//Tensione batteria in Volt
Intg=0			//Intero generico
volt!=0			//Tensione generica
Intg=0			//Intero generico


XMIT-
INPUT "" dummy
XMIT+
IF dummy=3
	GOTO TLoop
ELSE
	RETURN
ENDIF

TLoop:


//Loop di acquisizione


PSET Extern
//Piccola pausa
//oppure sleep o HYB


//Acquisizione canale 0 Temperatura

Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(CanaleChan(0))
NEXT j
CanaleADC(0)=INT(FLOAT(Somma/BProva)+0.5)/16

//Acquisizione rimanenti canali 2 e 3 Livello e Ph
FOR i = 2 TO 3
	Somma=0
	FOR j = 1 TO BProva
		Somma=Somma+CHAN(CanaleChan(i))
	NEXT j
	CanaleADC(i)=INT(FLOAT(Somma/BProva)+0.5)/16
NEXT i


//Acquisizione Canale 1 Conducibilita'
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(1)
NEXT j
CanaleADC(1)=INT(FLOAT(Somma/BProva)+0.5)/16



//Acquisizione canale 4 Temperatura interna
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(CanaleChan(4))
NEXT j
CanaleADC(4)=INT(FLOAT(Somma/BProva)+0.5)/16


GOSUB CheckBat			//Controlliamo la batteria principale
CanaleADC(5)=iBatt/16

//Fine acquisizione


Time2=?



//Stampa acquisizioni
FOR i = 0 to MaxCanali
	IF CanaleAttivo(i)=1
		PRINT CanaleADC(i)
	ELSE
		PRINT "0"
	ENDIF
NEXT i



//Attesa per la prossima misura
XMIT-
INPUT "" dummy
XMIT+
IF dummy=3
 GOTO TLoop
ENDIF
PCLR INH
PCLR Extern
Return

//---------------------------------------------------------------
ScaricoProgrammazione:
//Scarica la programmazione solamente e non i dati
Index=0
FOR i=0 TO 910
	dummy=GET(Index,#1)
	PRINT \dummy;	//CHR$(dummy);
NEXT i

RETURN


//---------------------------------------------------------------
TaraPh:
//Serve per la taratura del Ph
//prende una misura di Ph singola
//Piccola pausa
//oppure sleep o HYB
SLEEP 0
SLEEP 1000

//Acquisizione canale 3 Ph
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(3)
NEXT j
CanaleADC(3)=INT(FLOAT(Somma/BProva)+0.5)/16
PRINT CanaleADC(3)
RETURN

//--------------------------------------------------------------
TaraCond:
//Prende una misura di conducibilita'
//Piccola pausa
//oppure sleep o HYB
SLEEP 0
SLEEP 1000
//Acquisizione canale 1 Conducibilita'
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(1)
NEXT j
CanaleADC(1)=INT(FLOAT(Somma/BProva)+0.5)/16
PRINT CanaleADC(1)
RETURN

//--------------------------------------------------------------
TaraTemp:
//Prende una misura di Temperatura esterna
//Piccola pausa
//oppure sleep o HYB
SLEEP 0
SLEEP 200
//Acquisizione canale 0 Temperatura
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(0)
NEXT j
CanaleADC(0)=INT(FLOAT(Somma/BProva)+0.5)/16
PRINT CanaleADC(0)
RETURN

//--------------------------------------------------------------
TaraTempInt:
//Prende una misura di Temperatura Interna
//Piccola pausa
//oppure sleep o HYB
SLEEP 0
SLEEP 200
//Acquisizione canale 4 Temperatura interna
Somma=0
FOR j = 1 TO BProva
	Somma=Somma+CHAN(4)
NEXT j
CanaleADC(4)=INT(FLOAT(Somma/BProva)+0.5)/16
PRINT CanaleADC(4)
RETURN

//------------------------------------------------------------
CambiaOrario:
XMIT-
PRINT"Nuovo orario di accensione"
INPUT "Ora ->" aOra
VSTORE 10,aOra
INPUT "Minuti" aMinuti
VSTORE 11,aMinuti
PRINT"Nuovo orario di spegnimento"
INPUT "Ora ->" sOra
VSTORE 12, sOra
INPUT "Minuti" sMinuti
VSTORE 13, sMinuti

RETURN

//------------------------------------------------------------
ScaricaOrario:
aOra=VGET(10)		//Prende l'orario di accensione e spegnimento dall'UUEEPROM
aMinuti=VGET(11)
sOra=VGET(12)
sMinuti=VGET(13)
XMIT+
PRINT aOra
PRINT aMinuti
PRINT sOra
PRINT sMinuti

RETURN

//-------------------------------------------------------------
lBattFact:
//Stampa il fattore batteria contenuto in UEEPROM e in BattFact
XMIT+
BattFact! = ASFLT(VGET(14))
PRINT BattFact!

RETURN

//-------------------------------------------------------------
rBattFact:
//Memorizza il nuovo fattore batteria
XMIT-
INPUT "" BattFact!
VSTORE 14, BattFact!

RETURN

//-------------------------------------------------------------
ExternOn:
//Accensione linea Extern
PSET Extern
RETURN

//-------------------------------------------------------------
ExternOff:
//Spegnimento linea Extern
PCLR Extern
RETURN

//-------------------------------------------------------------
INHOn:
//Accensione linea INH
PSET INH
RETURN

//-------------------------------------------------------------
INHOff:
//Spegnimento linea INH
PCLR INH
RETURN

//-------------------------------------------------------------
rOrario:
//Stampa l'ora del TFX in formato data di VB
PRINT ?(5),"/",?(4),"/",?(3)," ",?(2),":",?(1),":",?(0)
RETURN

//-------------------------------------------------------------
rDFMAX:
//Stampa la quantita' di memoria libera per i dati
PRINT DFMAX
RETURN

//-------------------------------------------------------------
DumpRam:
XMIT+
PRINT"POSEIDON"
PRINT ?(5),"/",?(4),"/",?(3)," ",?(2),":",?(1),":",?(0)
PRINT
PRINT"Variables Dump"
PRINT
PRINT "TFX Modello ", MODEL/100
PRINT "Numero di serie ",SN
PRINT "Bytes occupati nella FlashMemory->",DFPNT
PRINT "Stazione -->",Stazione$
PRINT "Intervallo di campionamento  ",Interval," v"
PRINT "Orario di partenza ->",TP(5),"/",TP(4),"/",TP(3)," ",TP(2),":",TP(1),":",TP(0)
PRINT "Orario accensione modem ",aOra,":",aMinuti
PRINT "Orario spegnimento modem ",sOra,":",sMinuti
PSET Extern
GOSUB CheckBat
PCLR Extern
PRINT "Tensione batteria ",vBatt!," v"
PRINT "Tensione minima batteria ammessa-->",vBattRif!
PRINT "Fattore Moltiplicativo batteria-->",BattFact!
PRINT "Baud rate corrente ",BAUDGET
IF BBPWR = 0
	PRINT "Alimentazione esterna"
ELSE
	PRINT "Alimentazione batteria di backup"
ENDIF
PRINT"-------------------------------------"
XMIT+
FOR i = 0 TO MaxCanali
	IF CanaleAttivo(i)<>0
		Intg=CanaleNomep(i)
		GOSUB GETS2
		PRINT GETS2s$,",";
		Intg=CanaleUnitap(i)
		GOSUB GETS2
		PRINT GETS2s$,",";
		PRINT CanaleBitmin(i),",";
		PRINT CanaleBitmax(i),",",CanaleValmin!(i),",",CanaleValmax!(i),",";
		PRINT CanaleValoff!(i)
	ENDIF
NEXT i
RETURN

//-------------------------------------------------------------
GetStation:
// Scarica il nome della stazione
Intg=941

PRINT GETS(941)
RETURN

//Intg=941
//GOSUB GETS2
//PRINT GETS2s$
//RETURN



//-------------------------------------------------------------
TurnModemOn:
//Accende il modem
ModemOn=1
PSET ExtModem
RETURN

//-------------------------------------------------------------
TurnModemOff:
//Spegne il modem
ModemOn=0
PCLR ExtModem
RETURN

//-------------------------------------------------------------
PrintVersion:
//Stampa la versione del firmware
PRINT Versione$
RETURN


//------------------------------------------------------------
ComputeCecksum:
//Calcola il checksum del programma in RAM
//variabili
// checksum
checksum = 0			// IMPORTANT - start checkum at zero!
asm $
	ldx	#H'C000		; start of TFBASIC in RAM
_loop	clra			; always zero
	ldab	0,x		; get byte at current address
	addd	checksum+2	; add to LS word of checksum
	std	checksum+2	; update
	ldd	checksum	; get MS word of checksum
	adcb	#0
	adca	#0
	std	checksum	; update
	inx			; point to next location
	cpx	#H'FDC0		; reached the end?
	blo	_loop		; B/ if not at end of TFBASIC yet
	end
PRINT "Checksum=",checksum
RETURN

//------------------------------------------------------------
WarmBoot:
// this in-line assembly routine actually does starts the reset
asm $
	ldx	#0      ; TFBASIC assumes a checksum in these
	ldd	#0      ; two registers when it starts, we'll use zero
	sei             ; IMPORTANT - stop interrupts for reset
	jmp	H'FDFD  ; where vector too real start of TFBASIC is stored
	end
STOP

//------------------------------------------------------------
ColdBoot:
// this in-line assembly routine actually does starts the reset
asm $
	ldx	#H'FF00   ; will jump to this address, real vector there
	sei               ; IMPORTANT - stop interrupts for reset
	jmp	0,x       ; execute reset code
	end
STOP

//-------------------------------------------------------------
TurnModemOffTimer:
//Spegne il modem a tempo e poi lo riaccende. Serve per un reset
//Variabili
// ExtModem	Linea che comanda l'accensione del modem
// ModemOn	Flag che indica se il modem e' acceso
PRINT "Spengo..."
SLEEP 500
PCLR ExtModem
SLEEP 500
ModemOn=1
PSET ExtModem
RETURN




//*************************************************************************


CBREAK SottoComandi

SottoComandi:
XMIT+
PCLR Extern
PCLR INH
PRINT"Poseidon"


NuoviComandi2:

//PRINT"1  Acquisizione"
//PRINT"2  ScaricoDati"
//PRINT"8  InfoAcq"
//PRINT"99 Stop"
//PRINT
//PRINT"Comando"
XMIT-
INPUT "" Comando // ,1*100
XMIT+




//Qui si mette l'esecuzione dei vari comandi
IF Comando=1
	XMIT-
	GOTO NuovaAcquisizione		// Fa partire l'acquisizione
	tCom=?
ENDIF
IF Comando=2
	XMIT+
	GOSUB NuovoScaricoDati		// Scarica i dati
	tCom=?
ENDIF
IF Comando=8
	GOSUB NuovoInfoAcq			//Stampa informazioni sulle acquisizioni fatte
	tCom=?
ENDIF
IF Comando=99
	GOTO NuovoStopPrg		// Ferma il programma
ENDIF

Comando=0

GOTO NuoviComandi2

//****************************************************************
NuovaAcquisizione:
//Qui si fa ripartire l'acquisizione

//Acquisizione nome stazione

XMIT-
INPUT "" Stazione$;
XMIT+

//Input data e ora dal PC
Dummy=0
XMIT-
INPUT "" Dummy;
XMIT+
IF Dummy <> 1
	GOTO Noora
ENDIF

XMIT-
INPUT "" ?(5);	//Anno
INPUT "" ?(4);	//Mese
INPUT "" ?(3);	//Giorno
INPUT "" ?(2);	//Ora
INPUT "" ?(1);	//Minuti
INPUT "" ?(0);	//Secondi
XMIT+


STIME		//La scarica in ?
SETRTC		//Scarica ? sull'orologio del PIC
Noora:
READRTC
RTIME


XMIT-
INPUT "" Dummy;
XMIT+
IF Dummy=1
	XMIT-
	INPUT "" TP(5); // Anno
	INPUT "" TP(4); // Mese
	INPUT "" TP(3); // Giorno
	INPUT "" TP(2); // Ora
	INPUT "" TP(1); // Minuti
	INPUT "" TP(0); // Secondi
	XMIT+
	QuandoPar=0
ELSE

	FOR i = 0 TO 5				// Copia la data attuale
		TP(i)=?(i)
	NEXT i
	QuandoPar=1
ENDIF

FOR i = 0 TO 5			//Trasforma la data di partenza in numero
	?(i)=TP(i)
NEXT i
STIME Partenza		// Partenza e' un numero che contiene la data di partenza



XMIT-
INPUT "" Interval
XMIT+


FOR i = 0 TO MaxCanali
	XMIT-
	INPUT "" CanaleNome$
	CanaleNomep(i)=DFPNT
	IF CanaleNome$="" CanaleNome$=" "
	INPUT "" CanaleAttivo(i)
	INPUT "" CanaleUnita$
	CanaleUnitap(i)=DFPNT
	IF CanaleUnita$="" CanaleUnita$=" "
	INPUT "" CanaleBitmin(i)
	INPUT "" CanaleBitmax(i)
	INPUT "" CanaleValmin!(i)
	INPUT "" CanaleValmax!(i)
	INPUT "" CanaleValoff!(i)
	XMIT+
	CanaleADC(i)=0
	CanaleMisura(i)=0
	CanaleVolt(i)=0
	Spunt=DFPNT
NEXT i

EndHeader=DFPNT-1
StartData=DFPNT

XMIT+
PRINT "PARTITO!"			//Partiamo!
XMIT-	//Disabilita ogni output sulla RS232
CBREAK Com
SLEEP 0
SLEEP Delay1
PCLR Extern
PCLR INH

Scaricato=1
Dati=1
error=0
SLEEP 0
HYB 0

//Azzera il byte di oversleep (vedi manuale pag. 120)
POKE &H9E,0


RTIME
STIME Dummy
IF QuandoPar=1
	GOTO IniAcq
ENDIF


AStart=0			//Controllo che si sia raggiunta la data di partenza
AttesaStart:
REPEAT
	RTIME
        STIME Dummy
	IF Dummy>=Partenza
		AStart=1
	ENDIF

	RTIME
	//Siccome il confronto risulta complesso considerando ora e minuti separatamente
	//trasformo l'ora e minuti in ora decimale.
	Now!=?(2)+FLOAT(?(1))/60
	aOrad!=aOra+FLOAT(aMinuti)/60
	sOrad!=sOra+FLOAT(sMinuti)/60

	IF Now!>=aOrad! & Now! < sOrad
		IF ModemOn=0
			PSET ExtModem
			ModemOn=1
		ENDIF
	ELSE
	// controlla che non sia ora di spegnere

		IF ModemOn=1
			PCLR ExtModem
			ModemOn=0
		ENDIF
	ENDIF

	PSET Extern
	SLEEP 10
	PCLR Extern
	SLEEP 10
	PSET Extern
	SLEEP 10
	PCLR Extern


	PICINT 1,0
	HYB 0
	HYB 5
	IF INTSTATE=0
		Dummy=1
		SLEEP 0
		SLEEP 50
		GOTO AttesaStart
	ENDIF

        // controlla ogni 10 secondi che non sia l'ora di partire. Nell'attesa dorme
UNTIL AStart=1

IniAcq:

SLEEP 0

StartData=DFPNT		//Aggiornamento del puntatore di inizio dati

GOTO LoopAcq

//****************************************************************
NuovoInfoAcq:
		//Stampa informazioni sulle acquisizioni fatte
		//Al posto di DFPNT viene stampato il numero dei bytes da
		//scaricare escluso quelli che sarebbero gia' scaricati.

PRINT EndHeader+(DFPNT-StartData)
PSET Extern
SLEEP 50
GOSUB CheckBat			//Misura tensione batteria
PCLR Extern
PRINT #2.2F,vBatt!
PRINT SN
RETURN

//****************************************************************
NuovoScaricoDati:
RTIME


XMIT+
Index=0
FOR i=0 TO EndHeader			//Qui viene scaricato l'header
	dummy=GET(Index,#1)
	PRINT \dummy;	//CHR$(dummy);
NEXT i

FOR i= StartData TO DFPNT-1		//Qui vengono scaricati i dati
	dummy=GET(i,#1)
	PRINT \dummy;	//CHR$(dummy);
NEXT i

XMIT-
Scaricato=0
RETURN


//****************************************************************
NuovoStopPrg:

PRINT   //\13 \10;	//Primo CRLF
PRINT"#"
INPUT "" Dummy
PRINT /5
INPUT "" Dummy
PRINT "0"
PRINT"#"
PRINT "Poseidon"
RETURN

